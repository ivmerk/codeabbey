/*
Пусть мы выбрали некое исходное число X и строим от него последовательность значений по следующим правилам:
если X четное (т.е. X mod 2 = 0) тогда
    Xследующее = X / 2
иначе
    Xследующее = 3 * X + 1
Таким образом если X нечетно, последовательность растет - а если четно, то убывает. Например, с X = 15 мы получим:
15 46 23 70 35 106 53 160 80 40 20 10 5 16 8 4 2 1
После достижения 1 последовательность зацикливается 1 4 2 1 4 2 1....
Интрига заключается в том, что для любого начального X получаемая последовательность, по-видимому, рано или поздно достигает 1 - однако хотя это предположение было высказано как гипотеза Коллатца еще в 1937, до сих пор никто не смог ни доказать её, ни найти контрпример (т.е. число для которого последовательность либо входит в другой цикл, нежели 1 4 2 1 - либо растет бесконечно). Может быть повезет вам?
Ваша задача - для заданного исходного X посчитать сколько шагов требуется чтобы дойти до 1.
Входные данные содержат количество тестов в первой строке.
Вторая строка содержит сами тесты - т.е. исходные значения для которых нужно определить длину получаемых последовательностей.
Ответ должен содержать для каждого исходного значения полученное количество шагов (через пробел).
*/

#include <iostream>
int collatznumb(int n);
using namespace std;
int main()
{
int date;
int n=1; //количество чисел
cout << "input data" << "\n";
cin >> n;
cout << "\n";
int *res1 = new int[n]; 

for (int i = 0; i < n; i++){
cin >> date;        
res1[i] = collatznumb(date);

}
cout  << "\n" << "answer:" << "\n";
     for (int i=0; i < n; i++)
cout <<  res1[i] << " ";
delete [] res1;
return 0;
}
int collatznumb (int i){
        int res = 0;
        while (i > 1){
                res++;
                if (i%2 == 0)
                        i/=2;
                else i = 3 * i + 1;
        }
return res;
}
